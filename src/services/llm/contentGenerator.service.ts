// src/services/llm/contentGenerator.service.ts

import { z } from 'zod';
import { getOpenAiChatCompletion, LlmResponse } from './openai.service';
import { getConfig } from '../../config';
import OpenAI from 'openai';
import { UserSkillContext, SkillAnalysis } from './skillAnalyzer.service'; // For user context & skill analysis context for action days
// Importar tipos de analytics.service.ts para los insights
import { ContentOptimization, LearningPattern, StreakMaintenance } from './analytics.service';

const config = getConfig();

// --- Zod Schemas and TypeScript Types for Content Blocks ---

export const MainAudioContentSchema = z.object({
  type: z.literal("audio"),
  title: z.string().min(1),
  transcript: z.string().min(1, "Transcript cannot be empty."),
  audioUrl: z.string().min(1).describe("Placeholder like 'TTS_PENDING' or a temporary identifier. Actual URL to be generated by TTS service."),
  duration: z.number().int().positive().describe("Estimated duration in seconds, will be updated after TTS."),
  fun_fact: z.string().min(1),
  xp: z.number().int().default(20),
});
export type MainAudioContent = z.infer<typeof MainAudioContentSchema>;

export const KeyConceptSchema = z.object({
  term: z.string().min(1),
  definition: z.string().min(1),
});
export type KeyConcept = z.infer<typeof KeyConceptSchema>;

export const MainReadContentSchema = z.object({
  type: z.literal("read"),
  title: z.string().min(1),
  content: z.string().min(10, "Content should be substantial."),
  estimated_time: z.number().int().positive().describe("Estimated read time in minutes"),
  fun_fact: z.string().min(1),
  key_concepts: z.array(KeyConceptSchema).min(1, "At least one key concept is required."),
  xp: z.number().int().default(20),
});
export type MainReadContent = z.infer<typeof MainReadContentSchema>;

export const MainContentSchema = z.discriminatedUnion("type", [
  MainAudioContentSchema,
  MainReadContentSchema,
]);
export type MainContent = z.infer<typeof MainContentSchema>;

export const QuizMCQBlockSchema = z.object({
  type: z.literal("quiz_mcq"),
  question: z.string().min(1),
  options: z.array(z.string().min(1)).min(2, "At least two options required."),
  answer: z.number().int().min(0).describe("0-indexed answer"),
  explanation: z.string().min(1),
  xp: z.number().int().default(20),
});
export type QuizMCQBlock = z.infer<typeof QuizMCQBlockSchema>;

export const TrueFalseBlockSchema = z.object({
  type: z.literal("quiz_truefalse"),
  statement: z.string().min(1),
  answer: z.boolean(),
  explanation: z.string().min(1),
  xp: z.number().int().default(15),
});
export type TrueFalseBlock = z.infer<typeof TrueFalseBlockSchema>;

export const MatchToMeaningPairSchema = z.object({
  term: z.string().min(1),
  meaning: z.string().min(1),
});
export const MatchToMeaningBlockSchema = z.object({
  type: z.literal("match_meaning"),
  pairs: z.array(MatchToMeaningPairSchema).min(2, "At least two pairs required."),
  xp: z.number().int().default(25),
});
export type MatchToMeaningBlock = z.infer<typeof MatchToMeaningBlockSchema>;

export const ScenarioQuizBlockSchema = z.object({
  type: z.literal("scenario_quiz"),
  scenario: z.string().min(1),
  question: z.string().min(1),
  options: z.array(z.string().min(1)).min(2),
  answer: z.number().int().min(0),
  explanation: z.string().min(1),
  xp: z.number().int().default(30),
});
export type ScenarioQuizBlock = z.infer<typeof ScenarioQuizBlockSchema>;

export const ExerciseBlockSchema = z.discriminatedUnion("type", [
  QuizMCQBlockSchema,
  TrueFalseBlockSchema,
  MatchToMeaningBlockSchema,
  ScenarioQuizBlockSchema,
]);
export type ExerciseBlock = z.infer<typeof ExerciseBlockSchema>;

export const ActionTaskSchema = z.object({
  title: z.string().min(1),
  challenge_description: z.string().min(1),
  steps: z.array(z.string().min(1)).min(1, "At least one step is required."),
  time_estimate: z.string().min(1).describe("e.g., '30 minutes', '1-2 hours'"),
  tips: z.array(z.string().min(1)),
  real_world_context: z.string().min(1),
  success_criteria: z.array(z.string().min(1)).min(1, "At least one success criterion."),
  ski_motivation: z.string().min(1).describe("Motivational message from Ski the Fox."),
  difficulty_adaptation: z.enum(["easier", "standard", "harder"]).nullable().optional(),
  xp: z.number().int().min(30).max(150).default(75),
});
export type ActionTask = z.infer<typeof ActionTaskSchema>;

export const DayContentSchema = z.object({
  title: z.string().min(1),
  is_action_day: z.boolean(),
  objectives: z.array(z.string().min(1)).min(1, "At least one objective is required."),
  main_content: MainContentSchema.nullable().describe("The primary learning content for the day (audio or read). Should be null if is_action_day is true."),
  exercises: z.array(ExerciseBlockSchema)
    .describe("Exercises for the day. Can be empty or null for action days.")
    .nullable() 
    .optional(), 
  action_task: ActionTaskSchema.nullable().optional().describe("Task for an action day. Should be null if is_action_day is false. For action days, this is populated by a separate LLM call."),
  total_xp: z.number().int().nonnegative().default(0).describe("Initial XP estimated by LLM, to be recalculated by the system."),
  estimated_time: z.string().min(1).default("TBD").describe("Initial time estimated by LLM (e.g., '15 minutes'), to be recalculated by the system."),
}).refine(data => {
    if (data.is_action_day) {
        return data.main_content === null; 
    } else { 
        return data.main_content !== null && data.action_task === null;
    }
}, {
    message: "Structural inconsistency for DayContent: Action days must have null main_content. Non-action days must have main_content and null action_task. The controller is responsible for ensuring action_task is populated for action days after separate generation.",
});
export type DayContent = z.infer<typeof DayContentSchema>;

// --- Input Interfaces for Service Functions ---
export interface DayInfoForContent { 
  day_number: number;
  title: string;
  focus_area: string;
  is_action_day: boolean;
  objectives?: string[]; 
}

export interface UserDataForContent extends UserSkillContext { 
  name?: string; 
  skill: string; 
  learning_style: 'visual' | 'auditory' | 'kinesthetic' | 'reading' | string; 
}

// Definición más específica para adaptiveInsights
export interface AdaptiveInsightsForContent {
    content_optimization?: ContentOptimization; // De analytics.service
    relevant_learning_patterns?: LearningPattern[]; // De analytics.service
    key_insights?: string[]; // De analytics.service
    // Puedes añadir más campos específicos si son necesarios
}

export interface ContentGenerationInput {
  dayInfo: DayInfoForContent;
  userData: UserDataForContent;
  previousDayContentSummary?: { 
    title: string;
    userPerformance?: string; // e.g., "completed successfully", "struggled with quizzes"
  };
  adaptiveInsights?: AdaptiveInsightsForContent | null; // Usar el tipo más específico
}

export interface ActionDayInput {
  dayInfo: DayInfoForContent; 
  userData: UserDataForContent;
  skillAnalysisContext?: SkillAnalysis; 
  adaptiveInsights?: AdaptiveInsightsForContent | null; // Usar el tipo más específico
}

// --- System Prompts ---
const SYSTEM_PROMPT_CONTENT_GENERATOR = `You are an expert content creator for Skillix, an online microlearning platform. Your task is to generate engaging, personalized, and gamified daily learning content.
The user has a specific learning style and daily time availability. Adapt the content accordingly.
You will receive 'adaptiveInsights' which include 'content_optimization' (difficulty_adjustment, content_type_preferences, ideal_session_length_minutes, pacing_recommendation), 'relevant_learning_patterns', and 'key_insights' from a prior user analytics step. Use these insights to tailor the content.

**Output MUST be a single, valid JSON object matching the 'DayContent' structure.**

**Key Requirements for 'DayContent' JSON:**
-   \`title\`: Title for the day's lesson.
-   \`is_action_day\`: Boolean.
    * If \`is_action_day\` is **false** (it's a regular content day):
        * \`main_content\` (MANDATORY): An object, either 'audio' or 'read' type, based on \`userData.learning_style\` and potentially refined by \`adaptiveInsights.content_optimization.content_type_preferences\`. Include \`fun_fact\`, \`xp\`. For 'read', include \`key_concepts\`. For 'audio', include \`transcript\` and set \`audioUrl\` to "TTS_PENDING_[descriptive_title_for_tts_service]".
        * \`exercises\` (MANDATORY, 3-4 types): Array of exercise objects related to \`main_content\`. Mix types: 'quiz_mcq', 'quiz_truefalse', 'match_meaning', 'scenario_quiz'. Adjust difficulty based on \`adaptiveInsights.content_optimization.difficulty_adjustment\`.
        * \`action_task\`: MUST be \`null\`.
    * If \`is_action_day\` is **true**:
        * \`main_content\`: MUST be \`null\`.
        * \`exercises\`: Can be an empty array or \`null\`.
        * \`action_task\`: MUST be \`null\` in YOUR output. The calling system will use a different specialized agent ('action_day_creator') to generate the actual action_task and insert it later.
-   \`objectives\`: Array of strings (learning objectives for the day).
-   \`total_xp\`: Provide an initial estimate. The system will recalculate it.
-   \`estimated_time\`: Provide an initial estimate (e.g., "15 minutes"), considering \`adaptiveInsights.content_optimization.ideal_session_length_minutes\` if available. The system will recalculate it.

**Fun Facts Guidelines:** Surprising, interesting, topic-related, educational, short, memorable.

**Content Guidelines by Learning Style & Adaptive Insights:**
-   Apply \`userData.learning_style\`.
-   If \`adaptiveInsights.content_optimization.content_type_preferences\` are provided, give them higher priority.
-   Adjust complexity and depth based on \`adaptiveInsights.content_optimization.difficulty_adjustment\` and \`adaptiveInsights.relevant_learning_patterns\`.

**Time Scaling (Guideline, adapt with adaptiveInsights.content_optimization.pacing_recommendation):**
-   5 min: 1-2 main content parts + 2 quizzes.
-   10 min: 2-3 main content parts + 3 quizzes.
-   15 min: 3-4 main content parts + 3-4 quizzes.
-   20 min: 4-5 main content parts + 4 quizzes.

**XP Distribution (Guideline):**
-   Main Content (Read/Audio): 20 XP
-   MCQ: 20 XP; True/False: 15 XP; Match-to-Meaning: 25 XP; Scenario Quiz: 30 XP

**General Tone:** CLEAR, ENGAGING, PRACTICAL, MOTIVATING, APPROPRIATE for user's experience level.
Always include learning objectives.
Use \`adaptiveInsights.key_insights\` to further personalize tone or examples if applicable.
If previousDayContentSummary is provided, use it to make connections.
`;

const SYSTEM_PROMPT_ACTION_DAY_CREATOR = `You are an expert in designing engaging and practical "Action Day" challenges for the Skillix microlearning platform.
Action Days are hands-on, real-world application challenges.
You will receive 'adaptiveInsights' which include 'content_optimization' (difficulty_adjustment) and 'key_insights'. Use these to tailor the challenge.

**Output MUST be a single, valid JSON object matching the 'ActionTask' structure.**

**Key Requirements for 'ActionTask' JSON:**
-   \`title\`: Catchy challenge title.
-   \`challenge_description\`: Brief overview of the task.
-   \`steps\`: Array of clear, step-by-step instructions.
-   \`time_estimate\`: Realistic time (e.g., "20 minutes", "approx. 1 hour"), consider \`adaptiveInsights.content_optimization.ideal_session_length_minutes\`.
-   \`tips\`: Array of helpful tips for success.
-   \`real_world_context\`: Why this challenge matters or its real-world relevance.
-   \`success_criteria\`: Array of clear criteria for successful completion.
-   \`ski_motivation\`: A special, encouraging message from Ski the Fox (the platform mascot, who is playful and supportive 🦊).
-   \`difficulty_adaptation\`: Set this field ("easier", "standard", "harder") based on \`adaptiveInsights.content_optimization.difficulty_adjustment\`. If no insight, default to "standard".
-   \`xp\`: Typically 50-100 XP (provide an estimate).

**Challenge Design Principles:**
1.  PRACTICAL: Doable with common resources or within the app's context.
2.  RELEVANT: Directly applies recent learning (focus_area from DayInfo).
3.  ACHIEVABLE: Matches user's time and skill level (from \`userData\`), adjusted by \`adaptiveInsights\`.
4.  MEASURABLE: Clear success criteria.
5.  MOTIVATING: Frame as a fun mission or quest, not homework.

Adapt difficulty and scope based on user's experience, available time, and any \`adaptiveInsights\` or \`skillAnalysisContext\` provided.
Make it feel exciting!
`;

// --- Service Functions ---

function buildContentGenerationUserMessage(input: ContentGenerationInput): string {
  const { dayInfo, userData, previousDayContentSummary, adaptiveInsights } = input;
  let userMessage = `Generate engaging daily learning content for Skillix.

Target User Profile:
- Name: ${userData.name || 'Learner'}
- Skill: ${userData.skill}
- Experience Level: ${userData.experience}
- Available Daily Time: ${userData.time}
- Preferred Learning Style: ${userData.learning_style}
- Learning Goal: ${userData.goal}

Day Specifics:
- Day Number: ${dayInfo.day_number}
- Day Title: ${dayInfo.title}
- Focus Area: ${dayInfo.focus_area}
- Is Action Day: ${dayInfo.is_action_day}
${dayInfo.objectives ? `- Objectives for today: ${dayInfo.objectives.join(', ')}` : ''}
`;

  if (previousDayContentSummary) {
    userMessage += `\nPrevious Day Summary:
- Title: ${previousDayContentSummary.title}
${previousDayContentSummary.userPerformance ? `- User Performance: ${previousDayContentSummary.userPerformance}` : ''}
`;
  }
  if (adaptiveInsights) {
    userMessage += `\nAdaptive Learning Insights to consider (use these to tailor content, difficulty, and style):
${JSON.stringify(adaptiveInsights, null, 2)}
`;
  }
  userMessage += `\nRemember to adhere strictly to the 'DayContent' JSON output structure and all guidelines provided in the system prompt. If 'is_action_day' is true, set 'main_content' to null and 'action_task' to null (it will be generated separately). Ensure 'main_content.type' matches user's learning style if specified as 'audio' or 'read' for non-action days, but give preference to 'adaptiveInsights.content_optimization.content_type_preferences' if available.`;
  return userMessage;
}

function buildActionDayUserMessage(input: ActionDayInput): string {
  const { dayInfo, userData, skillAnalysisContext, adaptiveInsights } = input;
   let userMessage = `Design an Action Day challenge for Skillix.

Target User Profile:
- Name: ${userData.name || 'Learner'}
- Skill: ${userData.skill}
- Experience Level: ${userData.experience}
- Available Daily Time: ${userData.time}
- Learning Goal: ${userData.goal}

Action Day Specifics:
- Day Number: ${dayInfo.day_number}
- Day Title: ${dayInfo.title}
- Focus Area for this Action Day: ${dayInfo.focus_area}
`;
  if (skillAnalysisContext) {
    userMessage += `\nOverall Skill Context (from Skill Analysis):
- Skill Category: ${skillAnalysisContext.skill_category}
- Key Components relevant to this action day: (Focus on components related to '${dayInfo.focus_area}')
`;
  }
  if (adaptiveInsights) {
    userMessage += `\nAdaptive Learning Insights to consider for challenge design (especially 'difficulty_adjustment'):
${JSON.stringify(adaptiveInsights, null, 2)}
`;
  }
  userMessage += `\nRemember to adhere strictly to the 'ActionTask' JSON output structure and all guidelines provided in the system prompt. Set the 'difficulty_adaptation' field in the JSON based on 'adaptiveInsights.content_optimization.difficulty_adjustment'.`;
  return userMessage;
}

export async function generateDailyContentStructureWithOpenAI(
  input: ContentGenerationInput
): Promise<DayContent | null> {

  const userMessage = buildContentGenerationUserMessage(input);
  const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
    { role: 'system', content: SYSTEM_PROMPT_CONTENT_GENERATOR },
    { role: 'user', content: userMessage },
  ];

  console.log(`Requesting daily content structure for: Day ${input.dayInfo.day_number} - "${input.dayInfo.title}", Is Action Day: ${input.dayInfo.is_action_day}`);

  const response: LlmResponse = await getOpenAiChatCompletion({
    messages,
    model: config.openaiModel, 
    temperature: 0.7, 
    response_format: { type: 'json_object' },
  });

  if (!response.success || !response.content) {
    console.error('Error in OpenAI daily content structure generation:', response.error);
    return null;
  }

  try {
    const rawResult = JSON.parse(response.content);
    if (rawResult.is_action_day) {
        rawResult.main_content = null;
        rawResult.exercises = rawResult.exercises || null; 
        rawResult.action_task = null; 
    } else { 
        rawResult.action_task = null;
        if (rawResult.main_content === undefined || rawResult.main_content === null) {
             console.error("LLM Error: Non-action day MUST have main_content. LLM did not provide it.");
             console.error("Raw LLM output for non-action day missing main_content:", rawResult);
             throw new Error("Non-action day generated without main_content by LLM.");
        }
        rawResult.exercises = rawResult.exercises || []; 
    }

    const validatedResult = DayContentSchema.parse(rawResult);
    
    if (validatedResult.is_action_day && validatedResult.main_content !== null) {
        console.warn(`Action day (Day ${validatedResult.title}) structure has non-null main_content. Overriding to null.`);
        validatedResult.main_content = null;
    }
    if (!validatedResult.is_action_day && validatedResult.action_task !== null) {
        console.warn(`Content day (Day ${validatedResult.title}) structure has non-null action_task. Overriding to null.`);
        validatedResult.action_task = null;
    }
    if (!validatedResult.is_action_day && (!validatedResult.exercises || validatedResult.exercises.length === 0)) {
        console.warn(`Content day (Day ${validatedResult.title}) structure has no exercises. This might be acceptable depending on content type, but typically exercises are expected.`);
    }

    console.log(`Daily content structure generated and validated for: Day ${input.dayInfo.day_number} - "${validatedResult.title}"`);
    return validatedResult;
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error('Zod validation error for DayContent:', error.errors);
    } else {
      console.error('Error processing JSON response for DayContent from OpenAI:', error);
    }
    console.error('Original OpenAI content that failed parsing/validation:', response.content);
    return null;
  }
}

export async function generateActionDayTaskWithOpenAI(
  input: ActionDayInput
): Promise<ActionTask | null> {
  if (!input.dayInfo.is_action_day) {
    console.warn("generateActionDayTaskWithOpenAI called for a day not marked as action day. Ensure dayInfo.is_action_day is true in the input if an ActionTask is expected.");
  }

  const userMessage = buildActionDayUserMessage(input);
  const messages: OpenAI.Chat.ChatCompletionMessageParam[] = [
    { role: 'system', content: SYSTEM_PROMPT_ACTION_DAY_CREATOR },
    { role: 'user', content: userMessage },
  ];

  console.log(`Requesting Action Day task for: Day ${input.dayInfo.day_number} - "${input.dayInfo.title}"`);

  const response: LlmResponse = await getOpenAiChatCompletion({
    messages,
    model: config.openaiModel, 
    temperature: 0.75, 
    response_format: { type: 'json_object' },
  });

  if (!response.success || !response.content) {
    console.error('Error in OpenAI Action Day task generation:', response.error);
    return null;
  }

  try {
    const rawResult = JSON.parse(response.content);
    const validatedResult = ActionTaskSchema.parse(rawResult);
    
    console.log(`Action Day task generated and validated for: Day ${input.dayInfo.day_number} - "${validatedResult.title}"`);
    return validatedResult;
  } catch (error) {
    if (error instanceof z.ZodError) {
      console.error('Zod validation error for ActionTask:', error.errors);
    } else {
      console.error('Error parsing JSON response for ActionTask from OpenAI:', error);
    }
    console.error('Original OpenAI content that failed parsing/validation:', response.content);
    return null;
  }
}
