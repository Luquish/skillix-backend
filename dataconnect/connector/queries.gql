# # Example queries for a simple movie app.

# # @auth() directives control who can call each operation.
# # Anyone should be able to list all movies, so the auth level is set to PUBLIC
# query ListMovies @auth(level: PUBLIC) {
#   movies {
#     id
#     title
#     imageUrl
#     genre
#   }
# }

# # List all users, only admins should be able to list all users, so we use NO_ACCESS
# query ListUsers @auth(level: NO_ACCESS) {
#   users {
#     id
#     username
#   }
# }

# # Logged in users can list all their reviews and movie titles associated with the review
# # Since the query uses the uid of the current authenticated user, we set auth level to USER
# query ListUserReviews @auth(level: USER) {
#   user(key: { id_expr: "auth.uid" }) {
#     id
#     username
#     # <field>_on_<foreign_key_field> makes it easy to grab info from another table
#     # Here, we use it to grab all the reviews written by the user.
#     reviews: reviews_on_user {
#       rating
#       reviewDate
#       reviewText
#       movie {
#         id
#         title
#       }
#     }
#   }
# }

# # Get movie by id
# query GetMovieById($id: UUID!) @auth(level: PUBLIC) {
#   movie(id: $id) {
#     id
#     title
#     imageUrl
#     genre
#     metadata: movieMetadata_on_movie {
#       rating
#       releaseYear
#       description
#     }
#     reviews: reviews_on_movie {
#       reviewText
#       reviewDate
#       rating
#       user {
#         id
#         username
#       }
#     }
#   }
# }

# # Search for movies, actors, and reviews
# query SearchMovie($titleInput: String, $genre: String) @auth(level: PUBLIC) {
#   movies(
#     where: {
#       _and: [{ genre: { eq: $genre } }, { title: { contains: $titleInput } }]
#     }
#   ) {
#     id
#     title
#     genre
#     imageUrl
#   }
# }

# Estas consultas están diseñadas para ser llamadas por el SDK del cliente (React Native).
# Se asume que el schema.gql define los tipos y relaciones correspondientes.

# Consultas para la aplicación Skillix.

# Obtiene el contenido de un día específico para un plan de aprendizaje.
# El usuario debe estar autenticado y ser propietario del plan.
query GetDayContent($learningPlanId: UUID!, $dayNumber: Int!) @auth(level: USER) {
  dayContents(
    where: {
      section: { learningPlan: { id: { eq: $learningPlanId }, userFirebaseUid: { eq_expr: "auth.uid" } } },
      dayNumber: { eq: $dayNumber }
    },
    limit: 1
  ) {
    id
    title
    focusArea
    isActionDay
    objectives
    completionStatus
    mainContentItem_on_dayContent {
      id
      title
      textContent
      audioUrl
      estimatedReadTimeMinutes
      audioDurationSeconds
      funFact
      xp
      keyConcepts_on_mainContentItem {
        concept
        explanation
        emoji
      }
    }
    contentBlockItems_on_dayContent(orderBy: { order: ASC }) {
      id
      blockType
      title
      xp
      order
      estimatedMinutes
      quizDetails {
        id
        description
        quizQuestionDatas_on_quizDetails {
          question
          questionType
          explanation
          quizOptionDatas_on_question {
            optionText
            isCorrect
          }
        }
      }
      exerciseDetails {
        id
        instructions
        exerciseType
        matchPairs_on_exercise {
          prompt
          correctAnswer
        }
      }
    }
    actionTaskItem_on_dayContent {
      id
      title
      challengeDescription
      timeEstimateString
      tips
      realWorldContext
      successCriteria
      toviMotivation
      difficultyAdaptation
      xp
      actionStepItems_on_actionTaskItem(orderBy: { stepNumber: ASC }) {
        stepNumber
        description
        estimatedTimeSeconds
        isCompleted
      }
    }
  }
}

# Obtiene los analytics generados por el LLM para un usuario.
# El usuario debe estar autenticado y solo puede solicitar sus propios analytics.
query GetUserAnalytics @auth(level: USER) {
  userAnalytics(key: { userFirebaseUid_expr: "auth.uid" }) {
    id
    overallEngagementScore
    keyInsights
    learningPatternDatas_on_userAnalytics {
      patternType
      details
      confidenceScore
    }
    optimalLearningTime {
      timeOfDay
      confidence
      reasoning
    }
    contentOptimization {
      suggestionType
      details
      expectedImpact
    }
    streakMaintenanceAnalysis {
      recommendation
      timing
      confidence
    }
  }
}

# Obtiene el progreso general de un usuario, incluyendo su inscripción activa y datos de racha.
# Esta es la query principal para que el frontend obtenga el estado actual del usuario.
# El usuario debe estar autenticado.
query GetUserProgress @auth(level: USER) {
  enrollments(
    where: {
      userFirebaseUid: { eq_expr: "auth.uid" },
      status: { eq: ACTIVE }
    },
    limit: 1
  ) {
    id
    status
    enrollmentDate
    learningPlan {
      id
      skillName
      totalDurationWeeks
    }
  }
  streakData(key: { userFirebaseUid_expr: "auth.uid" }) {
    currentStreak
    longestStreak
    lastContributionDate
  }
}

# Obtiene mensajes de Tovi (antes Ski) para una situación dada.
# El usuario debe estar autenticado.
query GetToviMessages($situation: String!) @auth(level: USER) {
  toviMessages(
    where: {
      userFirebaseUid: { eq_expr: "auth.uid" },
      situation: { eq: $situation },
      isDelivered: { eq: false } # Opcional: para obtener solo mensajes nuevos
    },
    orderBy: { createdAt: DESC },
    limit: 5 # Limitar el número de mensajes
  ) {
    id
    situation
    message
    toviEmojiStyle
    animationSuggestion
    createdAt
    isDelivered
  }
}

# Query GetUserActiveLearningPlan eliminada para evitar redundancia.
# El frontend debe usar GetUserProgress para obtener el learningPlanId
# y luego, si necesita la estructura completa del plan, podría llamar a
# una query como GetLearningPlanDetails($planId: ID!) que se podría crear.
# Por ahora, se asume que GetUserProgress y GetDayContent son suficientes para empezar.

# Obtiene todas las inscripciones activas y pausadas de un usuario.
# Perfecta para poblar un "switcher" de cursos en la UI.
# El usuario debe estar autenticado.
query GetUserEnrollments @auth(level: USER) {
  enrollments(
    filter: { userFirebaseUid: { eq_expr: "auth.uid" } }
  ) {
    id
    status
    learningPlan {
      id
      skillName
    }
  }
}

# Obtiene todos los planes de aprendizaje para un usuario
query GetUserLearningPlans @auth(level: USER) {
  learningPlans(
    filter: { userFirebaseUid: { eq_expr: "auth.uid" } }
  ) {
    id
    skillName
  }
}
