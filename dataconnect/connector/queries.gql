# dataconnect/connector/queries.gql

# Estas consultas están diseñadas para ser llamadas por el SDK del cliente (React Native).
# Se asume que el schema.gql define los tipos y relaciones correspondientes.

"""
Obtiene el plan de aprendizaje activo de un usuario específico.
El usuario debe estar autenticado y solo puede solicitar su propio plan.
"""
query GetUserActiveLearningPlan @auth(level: USER) {
  # Asume que LearningPlan tiene un campo 'userId' y un campo 'isActive' (o una lógica similar para determinar actividad)
  # Esta consulta busca el LearningPlan por el firebaseUid (mapeado a userId en LearningPlan) del token de autenticación.
  learningPlanCollection( # Usar 'learningPlanCollection' si es el nombre generado para la colección
    filter: {
      userId: { eq_expr: "auth.uid" }, # Asume que 'userId' en LearningPlan es el firebaseUid
      isActive: { eq: true } # Necesitarías este campo en tu schema.gql para LearningPlan
    },
    first: 1 # Si solo puede haber un plan activo
  ) {
    edges {
      node {
        id
        skillName
        totalDurationWeeks
        dailyTimeMinutes
        skillLevelTarget
        # currentDay # Necesitarías un campo para esto, o calcularlo en el cliente/backend
        milestones
        progressMetrics
        flexibilityOptions
        sections(orderBy: { field: order, direction: ASC }) { # Asume que PlanSection tiene 'order'
          id
          title
          description
          order
          days(orderBy: { field: dayNumber, direction: ASC }) { # Asume que DayContent tiene 'dayNumber'
            id
            dayNumber
            title
            focusArea
            isActionDay
            objectives
            completionStatus
            # Podrías querer más detalles aquí o en una query separada para el día
          }
        }
      }
    }
  }
}

"""
Obtiene el contenido de un día específico para un plan de aprendizaje.
El usuario debe estar autenticado y ser propietario del plan.
"""
query GetDayContent($learningPlanId: ID!, $dayNumber: Int!) @auth(level: USER) {
  # Esta consulta busca un DayContent específico.
  # La seguridad se refuerza asegurando que el LearningPlan asociado pertenezca al usuario autenticado.
  dayContentCollection(
    filter: {
      # learningPlanId: { eq: $learningPlanId }, # Si DayContent tiene learningPlanId directamente
      section: { learningPlanId: { eq: $learningPlanId } }, # Si DayContent está bajo Section que tiene learningPlanId
      dayNumber: { eq: $dayNumber },
      # Filtro de seguridad adicional: el plan del día debe pertenecer al usuario autenticado
      section: { learningPlan: { userId: { eq_expr: "auth.uid" } } }
    },
    first: 1
  ) {
    edges {
      node {
        id
        title
        isActionDay
        objectives
        completionStatus
        mainContentItem { # Asume que esta es la relación a DbMainContent
          contentType
          title
          funFact
          xp
          audioDetails { audioUrl transcript durationSeconds voiceType }
          readDetails { contentHtml estimatedReadTimeMinutes keyConcepts { term definition order } }
        }
        contentBlocks(orderBy: { field: order, direction: ASC }) { # Asume que ContentBlock tiene 'order'
          id
          blockType
          title
          xp
          order
          estimatedMinutes
          quizDetails {
            quizType
            questions(orderBy: { field: order, direction: ASC }) {
              id
              questionText
              explanation
              order
              trueFalseAnswer
              matchPairsJson
              scenarioText
              options(orderBy: { field: order, direction: ASC }) {
                id
                optionText
                isCorrect
                order
              }
            }
          }
          exerciseDetails {
            exerciseType
            instructions
            exerciseDataJson
          }
        }
        actionTaskItem { # Asume que esta es la relación a DbActionTask
          title
          challengeDescription
          timeEstimateString
          tips
          realWorldContext
          successCriteria
          skiMotivation
          difficultyAdaptation
          xp
          steps(orderBy: { field: order, direction: ASC }) {
            instruction
            order
          }
        }
        # totalXp y estimatedTime podrían ser campos calculados o almacenados en DayContent
      }
    }
  }
}

"""
Obtiene los analytics de un usuario específico.
El usuario debe estar autenticado y solo puede solicitar sus propios analytics.
"""
query GetUserAnalytics @auth(level: USER) {
  # Asume una tabla UserAnalyticsEntry y que quieres la más reciente o un resumen.
  # Si es una entrada única por usuario, usa userAnalytics(filter: {userId: {eq_expr: "auth.uid"}})
  userAnalyticsEntryCollection(
    filter: { userId: { eq_expr: "auth.uid" } },
    orderBy: { field: date, direction: DESC }, # O el campo de timestamp relevante
    first: 1 # Para la entrada más reciente
  ) {
    edges {
      node {
        id
        date
        totalXpEarnedThisDay
        sessionsCountThisDay
        timeSpentLearningMinutesThisDay
        contentBlocksCompletedThisDay
        quizAverageScoreThisDay
        currentStreakForDate
        llmLearningPatternsJson
        llmOptimalTimeJson
        llmContentOptimizationJson
        llmStreakMaintenanceJson
        llmGeneratedOverallEngagementScore
        llmGeneratedKeyInsights
      }
    }
  }
}

"""
Obtiene el progreso general de un usuario, incluyendo su inscripción activa y datos de racha.
El usuario debe estar autenticado.
"""
query GetUserProgress @auth(level: USER) {
  # Obtener la inscripción activa del usuario
  enrollmentCollection(
    filter: {
      userId: { eq_expr: "auth.uid" },
      status: { in: [PENDING, IN_PROGRESS] } # Asumiendo que estos son estados activos
    },
    orderBy: { field: createdAt, direction: DESC}, # La más reciente si hay varias
    first: 1
  ) {
    edges {
      node {
        id
        status
        currentDayNumber
        totalXpEarned
        learningPlan {
            id
            skillName
            totalDurationWeeks
        }
        # Podrías añadir más campos de Enrollment o LearningPlan aquí
      }
    }
  }
  # Obtener datos de racha del usuario
  streakDataCollection(filter: { userId: { eq_expr: "auth.uid" } }, first: 1) {
    edges {
      node {
        id
        currentStreak
        longestStreak
        lastContributionDate
      }
    }
  }
}


"""
Obtiene mensajes de Ski personalizados para una situación dada.
El usuario debe estar autenticado.
"""
query GetSkiMessages($situation: String!) @auth(level: USER) {
  # Asume una tabla SkiMessage o Notification con un campo 'userId' y 'situation'
  # y que quieres los no leídos o los más recientes para esa situación.
  notificationCollection( # O el nombre de tu tabla de mensajes de Ski
    filter: {
      userId: { eq_expr: "auth.uid" },
      type: { eq: "SKI_MESSAGE" }, # Asumiendo un campo 'type' para diferenciar notificaciones
      # Podrías tener un campo específico como 'situation' o usar 'dataJson' para filtrar por situación.
      # Ejemplo si 'dataJson' contiene { "situation": "..." }:
      # dataJson_CONTAINS: $situation # La sintaxis exacta para filtrar JSON puede variar
      # Por ahora, asumimos que 'title' o 'body' podrían contener la situación o hay un campo dedicado.
      # Este filtro es un placeholder y necesitará ajuste según tu schema.gql:
      # title: { contains: $situation } # Ejemplo muy simplificado
    },
    orderBy: { field: createdAt, direction: DESC },
    first: 5 # Limitar el número de mensajes
  ) {
    edges {
      node {
        id
        title # Si el mensaje de Ski está en el título
        body  # O en el cuerpo
        # Si tienes campos específicos en tu tabla de mensajes de Ski:
        # message
        # emojiStyle
        # animationSuggestion
        createdAt
        isRead
      }
    }
  }
}
